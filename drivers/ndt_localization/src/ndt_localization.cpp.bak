/**
 * @brief
 *
 * @file ndt_localization.cpp
 * @author jyakaranda
 * @date 2018-09-20
 */

#include "ndt_localization/ndt_localization.h"

#include <exception>

namespace NDTLocalization {

void OdomImuCB(const geometry_msgs::PoseStamped::ConstPtr &msg) { geometryPose2Pose(msg->pose, predict_pose_odom_); }

void feedbackCB(const can_msgs::vehicle_status::ConstPtr &msg) { cur_speed = msg->cur_speed; }

void initialPoseCB(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr &msg) {
    if (msg->header.frame_id != param_map_frame_) {
        ROS_WARN("Please initialize pose under %s frame.", param_map_frame_.c_str());
        pose_init_ = false;
        return;
    }
    geometryPose2Pose(msg->pose.pose, initial_pose_);

    pre_pose_ = pre_pose_odom_ = current_pose_odom_ = current_pose_ = initial_pose_;
    pose_init_ = true;

    std::cout << "[NDT localization] Initial pose with:" << std::endl;
    std::cout << "    init_x: " << initial_pose_.x << std::endl;
    std::cout << "    init_y: " << initial_pose_.y << std::endl;
    std::cout << "    init_z: " << initial_pose_.z << std::endl;
    std::cout << " init_roll: " << initial_pose_.roll << std::endl;
    std::cout << "init_pitch: " << initial_pose_.pitch << std::endl;
    std::cout << "  init_yaw: " << initial_pose_.yaw << std::endl;
    ROS_INFO("-------------Current pose initialized.----------");
}

void init_pose_with_param() {
    ROS_INFO("Init pose with param");
    ros::NodeHandle pnh_("~");
    pnh_.param<double>("init_x", initial_pose_.x, 0.0);
    pnh_.param<double>("init_y", initial_pose_.y, 0.0);
    pnh_.param<double>("init_z", initial_pose_.z, 0.0);
    pnh_.param<double>("init_roll", initial_pose_.roll, 0.0);
    pnh_.param<double>("init_pitch", initial_pose_.pitch, 0.0);
    pnh_.param<double>("init_yaw", initial_pose_.yaw, 0.0);

    pre_pose_ = pre_pose_odom_ = current_pose_odom_ = current_pose_ = initial_pose_;
    pose_init_ = true;

    offset_odom_.reset();
    offset_imu_.reset();

    std::cout << "Initial pose with:" << std::endl;
    std::cout << "    init_x: " << initial_pose_.x << std::endl;
    std::cout << "    init_y: " << initial_pose_.y << std::endl;
    std::cout << "    init_z: " << initial_pose_.z << std::endl;
    std::cout << " init_roll: " << initial_pose_.roll << std::endl;
    std::cout << "init_pitch: " << initial_pose_.pitch << std::endl;
    std::cout << "  init_yaw: " << initial_pose_.yaw << std::endl;
    ROS_INFO("Current pose initialized.");
}

bool load_map(std::string map_file) {
    ros::NodeHandle nh_;
    pub_global_map = nh_.advertise<sensor_msgs::PointCloud2>("/ndt/loaded_map", 10);  // 当使用一次性载入全局地图时,发布一次 // TODO取消掉该方式
    sensor_msgs::PointCloud2::Ptr msg_globalmap(new sensor_msgs::PointCloud2);
    int res = pcl::io::loadPCDFile(map_file, *msg_globalmap);
    // if (res != 0)
    // {
    //     ROS_WARN("[ndt_localization] Cann't load map, waitting for /points_map to update target-map");
    //     return false;
    // }
    pcl::fromROSMsg(*msg_globalmap, model_pc_);
    model_pc_num_ = msg_globalmap->width;
    msg_globalmap->header.frame_id = "map";
    pub_global_map.publish(*msg_globalmap);
    std::cout << "Success load map: " << map_file << std::endl;

    // if (!pose_init_)
    // {
    //     ROS_WARN("initial pose not set, cannot update target_map");
    //     return false;
    // }
    PointCloudT::Ptr target_map_ptr(new PointCloudT(model_pc_));

    // set NDT target
    pthread_mutex_lock(&mutex);

    if (param_method_type_ == METHOD_CUDA) {
#ifdef CUDA_FOUND
        anh_gpu_ndt_ptr->setResolution(param_ndt_resolution_);
        anh_gpu_ndt_ptr->setInputTarget(target_map_ptr);
        anh_gpu_ndt_ptr->setMaximumIterations(param_ndt_max_iterations_);
        anh_gpu_ndt_ptr->setStepSize(param_ndt_step_size_);
        anh_gpu_ndt_ptr->setTransformationEpsilon(param_ndt_epsilon_);

        PointCloudT::Ptr dummy_scan_ptr(new pcl::PointCloud<pcl::PointXYZ>());
        PointT dummy_point;
        dummy_scan_ptr->push_back(dummy_point);  // ????
        anh_gpu_ndt_ptr->setInputSource(dummy_scan_ptr);

        anh_gpu_ndt_ptr->align(Eigen::Matrix4f::Identity());

#else
        ROS_ERROR("param method_type set to cuda, but cuda_found not defined!");
#endif
    } else if (param_method_type_ == METHOD_OMP) {
#ifdef USE_OMP
        PointCloudT::Ptr output_cloud(new PointCloudT());
        omp_ndt_.setResolution(param_ndt_resolution_);
        omp_ndt_.setInputTarget(target_map_ptr);
        omp_ndt_.setMaximumIterations(param_ndt_max_iterations_);
        omp_ndt_.setStepSize(param_ndt_step_size_);
        omp_ndt_.setTransformationEpsilon(param_ndt_epsilon_);
        omp_ndt_.align(*output_cloud, Eigen::Matrix4f::Identity());
#else
        ROS_ERROR("param method_type set to omp, but use_omp not defined!");
#endif
    } else if (param_method_type_ == METHOD_CPU) {
        cpu_ndt_.setResolution(param_ndt_resolution_);
        cpu_ndt_.setInputTarget(target_map_ptr);
        cpu_ndt_.setMaximumIterations(param_ndt_max_iterations_);
        cpu_ndt_.setStepSize(param_ndt_step_size_);
        cpu_ndt_.setTransformationEpsilon(param_ndt_epsilon_);

        PointCloudT::Ptr dummy_scan_ptr(new pcl::PointCloud<pcl::PointXYZ>());
        PointT dummy_point;
        dummy_scan_ptr->push_back(dummy_point);  // ????
        cpu_ndt_.setInputSource(dummy_scan_ptr);

        cpu_ndt_.align(Eigen::Matrix4f::Identity());
    } else {
        PointCloudT::Ptr output_cloud(new PointCloudT());
        ndt_.setResolution(param_ndt_resolution_);
        ndt_.setInputTarget(target_map_ptr);
        ndt_.setMaximumIterations(param_ndt_max_iterations_);
        ndt_.setStepSize(param_ndt_step_size_);
        ndt_.setTransformationEpsilon(param_ndt_epsilon_);
        ndt_.align(*output_cloud, Eigen::Matrix4f::Identity());
    }

    map_init_ = true;
    pthread_mutex_unlock(&mutex);
    ROS_INFO("Update target-map with %d points.", model_pc_num_);
    return true;
}

void mapCB(const sensor_msgs::PointCloud2::ConstPtr &msg) {
    ROS_INFO("[ndt_localization] received /points_map");
    if (model_pc_num_ == msg->width) {
        // suppose it is same map.
        return;
    }
    // if (!pose_init_)
    // {
    //     ROS_WARN("initial pose not set, cannot update target_map");
    //     return;
    // }
    ros::Time t1 = ros::Time::now();
    // model_pc_.clear();
    model_pc_num_ = msg->width;
    pcl::fromROSMsg(*msg, model_pc_);
    PointCloudT::Ptr target_map_ptr(new PointCloudT(model_pc_));

    // set NDT target
    if (param_method_type_ == METHOD_CUDA) {
#ifdef CUDA_FOUND
        std::shared_ptr<gpu::GNormalDistributionsTransform> new_anh_gpu_ndt_ptr = std::make_shared<gpu::GNormalDistributionsTransform>();
        new_anh_gpu_ndt_ptr->setResolution(param_ndt_resolution_);
        new_anh_gpu_ndt_ptr->setInputTarget(target_map_ptr);
        new_anh_gpu_ndt_ptr->setMaximumIterations(param_ndt_max_iterations_);
        new_anh_gpu_ndt_ptr->setStepSize(param_ndt_step_size_);
        new_anh_gpu_ndt_ptr->setTransformationEpsilon(param_ndt_epsilon_);

        PointCloudT::Ptr dummy_scan_ptr(new PointCloudT());
        PointT dummy_point;
        dummy_scan_ptr->push_back(dummy_point);  // ????
        new_anh_gpu_ndt_ptr->setInputSource(dummy_scan_ptr);
        new_anh_gpu_ndt_ptr->align(Eigen::Matrix4f::Identity());

        pthread_mutex_lock(&mutex);
        anh_gpu_ndt_ptr = new_anh_gpu_ndt_ptr;
        pthread_mutex_unlock(&mutex);

#else
        ROS_ERROR("param method_type set to cuda, but cuda_found not defined!");
#endif
    } else if (param_method_type_ == METHOD_OMP) {
#ifdef USE_OMP
        pcl_omp::NormalDistributionsTransform<PointT, PointT> new_omp_ndt;
        PointCloudT::Ptr output_cloud(new PointCloudT());
        new_omp_ndt.setResolution(param_ndt_resolution_);
        new_omp_ndt.setInputTarget(target_map_ptr);
        new_omp_ndt.setMaximumIterations(param_ndt_max_iterations_);
        new_omp_ndt.setStepSize(param_ndt_step_size_);
        new_omp_ndt.setTransformationEpsilon(param_ndt_epsilon_);
        new_omp_ndt.align(*output_cloud, Eigen::Matrix4f::Identity());

        pthread_mutex_lock(&mutex);
        omp_ndt_ = new_omp_ndt;
        pthread_mutex_unlock(&mutex);
#else
        ROS_ERROR("param method_type set to omp, but use_omp not defined!");
#endif
    } else if (param_method_type_ == METHOD_CPU) {
        cpu::NormalDistributionsTransform<PointT, PointT> new_cpu_ndt;
        new_cpu_ndt.setResolution(param_ndt_resolution_);
        new_cpu_ndt.setInputTarget(target_map_ptr);
        new_cpu_ndt.setMaximumIterations(param_ndt_max_iterations_);
        new_cpu_ndt.setStepSize(param_ndt_step_size_);
        new_cpu_ndt.setTransformationEpsilon(param_ndt_epsilon_);

        PointCloudT::Ptr dummy_scan_ptr(new PointCloudT());
        PointT dummy_point;
        dummy_scan_ptr->push_back(dummy_point);  // ????
        new_cpu_ndt.setInputSource(dummy_scan_ptr);
        new_cpu_ndt.align(Eigen::Matrix4f::Identity());

        pthread_mutex_lock(&mutex);
        cpu_ndt_ = new_cpu_ndt;
        pthread_mutex_unlock(&mutex);
    } else {
        pcl::NormalDistributionsTransform<PointT, PointT> new_ndt;
        PointCloudT::Ptr output_cloud(new PointCloudT());
        new_ndt.setResolution(param_ndt_resolution_);
        new_ndt.setInputTarget(target_map_ptr);
        new_ndt.setMaximumIterations(param_ndt_max_iterations_);
        new_ndt.setStepSize(param_ndt_step_size_);
        new_ndt.setTransformationEpsilon(param_ndt_epsilon_);
        new_ndt.align(*output_cloud, Eigen::Matrix4f::Identity());

        pthread_mutex_lock(&mutex);
        ndt_ = new_ndt;
        pthread_mutex_unlock(&mutex);
    }

    map_init_ = true;
    ros::Time t2 = ros::Time::now();
    ROS_INFO("[ndt_localization] Update target-map with %d points, time: %f seconds", model_pc_num_, (t2 - t1).toSec());
}

/**
 * 1. get data points
 * 2. match data points to model points(map)
 * 2.1 caculate score function: put the point to corresponding pdf, and sum it up
 * 2.2 optimize transformation matrix(position) using Newton method until score function is converged
 */
void pointCloudCB(const sensor_msgs::PointCloud2::ConstPtr &msg) {
    // TODO main function
    // ros::Time st_time = ros::Time::now();
    // if (pre_time = 0.0) {
    //     pre_time = msg->header.stamp.toSec();
    //     return;
    // }
    static ros::Time pre_t = ros::Time::now();
    ros::Time cur_t = ros::Time::now();
    if (!map_init_ && (cur_t - pre_t).toSec() > 1.0) {
        ROS_WARN_STREAM("Target-map not init, cann't conduct localization.");
        pre_t = cur_t;
    }
    if (!pose_init_ && (cur_t - pre_t).toSec() > 1.0) {
        ROS_WARN_STREAM("InitPose not init, cann't conduct localization.");
        pre_t = cur_t;
    }
    if (!map_init_ || !pose_init_) {
        return;
    }

    PointCloudT scan;
    PointCloudT::Ptr tmp(new PointCloudT());
    pcl::fromROSMsg(*msg, *tmp);
    pcl::PointCloud<PointT>::Ptr local_pc(new PointCloudT());
    // local_pc = tmp;
    // 过滤车身点和最远点
    for (auto p = tmp->begin(); p != tmp->end(); p++) {
        double r = sqrt(pow(p->x, 2.0) + pow(p->y, 2.0));
        if (r < 100){
            if (!(-1.2 < p->x < 1.0 && -0.6 < p->y < 0.6)){
                local_pc->push_back(*p);
            }
        }
        // if (min_scan_range < r && r < max_scan_range) {
        //     scan.push_back(p);
        // }
    }

    
    PointCloudT::Ptr scan_ptr(new PointCloudT());

    pcl::VoxelGrid<pcl::PointXYZ> voxel_grid_filter;
    voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
    voxel_grid_filter.setInputCloud(local_pc);
    voxel_grid_filter.filter(*scan_ptr);
    // ROS_WARN("filtered size: %d",scan_ptr->points.size());

    PointCloudT::Ptr output_cloud(new PointCloudT());
    Eigen::Matrix4f init_guess;
    Eigen::Matrix4f final_tf;
    Eigen::Matrix4f base_tf;
    pose predict_ndt_pose;
    pose ndt_pose;

    // 选择使用predict_odom_pose 还是pre_ndt_pose作为初始查找值
    if (param_use_odom_) {
        predict_ndt_pose = predict_pose_odom_;
    } else {
        predict_ndt_pose = pre_pose_;
    }

    Eigen::Translation3f init_translation(predict_ndt_pose.x, predict_ndt_pose.y, predict_ndt_pose.z);
    Eigen::AngleAxisf init_rotation_x(predict_ndt_pose.roll, Eigen::Vector3f::UnitX());
    Eigen::AngleAxisf init_rotation_y(predict_ndt_pose.pitch, Eigen::Vector3f::UnitY());
    Eigen::AngleAxisf init_rotation_z(predict_ndt_pose.yaw, Eigen::Vector3f::UnitZ());
    // predict_pose_ndt*odom is map_link->base_link; but init_guess matrix should be under the transform of map_link->laser_link   ===that's why
    // <*tf_btol>
    init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol_;

    ros::Time align_start, align_end, getFitnessScore_start, getFitnessScore_end;

    pthread_mutex_lock(&mutex);
    ros::Time st_time = ros::Time::now();
    if (param_method_type_ == METHOD_CUDA) {
#ifdef CUDA_FOUND
        anh_gpu_ndt_ptr->setInputSource(scan_ptr);
        // if (param_debug_)
        // {
        //   ROS_INFO("Start align cuda");
        // }
        align_start = ros::Time::now();
        anh_gpu_ndt_ptr->align(init_guess);
        align_end = ros::Time::now();

        final_tf = anh_gpu_ndt_ptr->getFinalTransformation();
        has_converged_ = anh_gpu_ndt_ptr->hasConverged();
        iteration_ = anh_gpu_ndt_ptr->getFinalNumIteration();
        trans_probability_ = anh_gpu_ndt_ptr->getTransformationProbability();

        getFitnessScore_start = ros::Time::now();
        fitness_score_ = anh_gpu_ndt_ptr->getFitnessScore();
        getFitnessScore_end = ros::Time::now();
#else
        ROS_ERROR("param method_type set true, but cuda not found!");
#endif
    } else if (param_method_type_ == METHOD_OMP) {
#ifdef USE_OMP
        if (param_debug_) {
            ROS_INFO("Start align omp");
        }
        omp_ndt_.setInputSource(scan_ptr);

        align_start = ros::Time::now();
        omp_ndt_.align(*output_cloud, init_guess);
        align_end = ros::Time::now();

        final_tf = omp_ndt_.getFinalTransformation();
        has_converged_ = omp_ndt_.hasConverged();
        iteration_ = omp_ndt_.getFinalNumIteration();
        trans_probability_ = omp_ndt_.getTransformationProbability();

        getFitnessScore_start = ros::Time::now();
        fitness_score_ = omp_ndt_.getFitnessScore();
        getFitnessScore_end = ros::Time::now();
#else
        ROS_ERROR("param method_type set to omp, but use_omp not defined!");
#endif
    } else if (param_method_type_ == METHOD_CPU) {
        cpu_ndt_.setInputSource(scan_ptr);
        if (param_debug_) {
            ROS_INFO("Start align cpu");
        }
        align_start = ros::Time::now();
        cpu_ndt_.align(init_guess);
        align_end = ros::Time::now();

        final_tf = cpu_ndt_.getFinalTransformation();
        has_converged_ = cpu_ndt_.hasConverged();
        iteration_ = cpu_ndt_.getFinalNumIteration();
        trans_probability_ = cpu_ndt_.getTransformationProbability();

        getFitnessScore_start = ros::Time::now();
        fitness_score_ = cpu_ndt_.getFitnessScore();
        getFitnessScore_end = ros::Time::now();
    } else {
        ndt_.setInputSource(scan_ptr);

        if (param_debug_) {
            ROS_INFO("Start align pcl");
        }
        align_start = ros::Time::now();
        ndt_.align(*output_cloud, init_guess);
        align_end = ros::Time::now();

        final_tf = ndt_.getFinalTransformation();
        has_converged_ = ndt_.hasConverged();
        iteration_ = ndt_.getFinalNumIteration();
        trans_probability_ = ndt_.getTransformationProbability();

        getFitnessScore_start = ros::Time::now();
        fitness_score_ = ndt_.getFitnessScore();
        getFitnessScore_end = ros::Time::now();
    }
    if (param_debug_) {
        std::cout << "iteration: " << iteration_ << std::endl;
        std::cout << "trans_probability: " << trans_probability_ << std::endl;
        std::cout << "fitness_score_: " << fitness_score_ << std::endl;
        std::cout << "total used_time: " << ros::Time::now() - st_time << std::endl;
        std::cout << "--------------------\n\n" << std::endl;
    }

    pthread_mutex_unlock(&mutex);

    base_tf = final_tf * tf_btol_.inverse();
    tf::Matrix3x3 mat_b;
    mat_b.setValue(static_cast<double>(base_tf(0, 0)), static_cast<double>(base_tf(0, 1)), static_cast<double>(base_tf(0, 2)),
                   static_cast<double>(base_tf(1, 0)), static_cast<double>(base_tf(1, 1)), static_cast<double>(base_tf(1, 2)),
                   static_cast<double>(base_tf(2, 0)), static_cast<double>(base_tf(2, 1)), static_cast<double>(base_tf(2, 2)));

    ndt_pose.x = base_tf(0, 3);
    ndt_pose.y = base_tf(1, 3);
    ndt_pose.z = base_tf(2, 3);
    mat_b.getEulerYPR(ndt_pose.yaw, ndt_pose.pitch, ndt_pose.roll);

    // TODO:: 使用更准确的判断方法
    bool use_predict_pose = false;
    if (param_use_odom_) {
        predict_pose_error_ = std::sqrt((ndt_pose.x - predict_ndt_pose.x) * (ndt_pose.x - predict_ndt_pose.x) +
                                        (ndt_pose.y - predict_ndt_pose.y) * (ndt_pose.y - predict_ndt_pose.y) +
                                        (ndt_pose.z - predict_ndt_pose.z) * (ndt_pose.z - predict_ndt_pose.z));
        if (predict_pose_error_ <= param_predict_error_thresh_)  // 当odom_pose和ndt_pose相差不大时,使用ndt_pose // 动态阈值判断
        {
            use_predict_pose = false;
        } else  // 当odom_pose和ndt_pose相差较大时,说明ndt丢失位置,此时使用不太准确的odom_pose
        {
            use_predict_pose = true;
        }
        // TODO::使用更复杂的逻辑判断ndt是否丢失位置,比如对过去>10个点做二次拟合,评价损失函数等
    }

    if (!use_predict_pose) {
        current_pose_ = ndt_pose;
    } else {
        current_pose_ = predict_ndt_pose;
        ROS_WARN("Use odom predict pose");
    }

    automotive_msgs::NDTStat msg_ndt_state_;
    msg_ndt_state_.score = fitness_score_;
    msg_ndt_state_.exe_time = (align_end - align_start).toSec();
    msg_ndt_state_.iteration = iteration_;
    msg_ndt_state_.use_predict_pose = use_predict_pose;
    msg_ndt_state_.velocity = cur_speed;
    // msg_ndt_state_.acceleration =
    pub_ndt_state_.publish(msg_ndt_state_);
    // }
    pose2GeometryPose(msg_current_pose_.pose, current_pose_);
    msg_current_pose_.header.stamp = msg->header.stamp;  // current pose is under "map_frame"
    msg_current_pose_.header.frame_id = param_map_frame_;
    pub_current_pose_.publish(msg_current_pose_);

    tf::Quaternion tmp_q;
    static tf::TransformBroadcaster tf_broadcaster_;
    tmp_q.setRPY(current_pose_.roll, current_pose_.pitch, current_pose_.yaw);
    tf::Transform transform2(tmp_q, tf::Vector3(current_pose_.x, current_pose_.y, current_pose_.z));
    tf_broadcaster_.sendTransform(tf::StampedTransform(transform2, ros::Time::now(), param_map_frame_, param_base_frame_));

    static pose last_added_pose = current_pose_;
    double shift = sqrt(pow(current_pose_.x - last_added_pose.x, 2.0) + pow(current_pose_.y - last_added_pose.y, 2.0));
    if (shift > 0.3) {
        history_trajectory.poses.push_back(msg_current_pose_);
        history_trajectory_pub.publish(history_trajectory);
        last_added_pose = current_pose_;
    }
    pre_pose_ = current_pose_;
    offset_odom_.reset();
}

void *thread_func(void *args) {
    ros::NodeHandle nh_map;
    ros::CallbackQueue map_callback_queue;
    nh_map.setCallbackQueue(&map_callback_queue);

    // TODO::如果想要接收动态加载的点云，就把这行打开
    sub_map_ = nh_map.subscribe<sensor_msgs::PointCloud2>("/points_map", 10, mapCB);
    ros::Rate ros_rate(10);
    while (nh_map.ok()) {
        map_callback_queue.callAvailable(ros::WallDuration());
        ros_rate.sleep();
    }

    return nullptr;
}

bool init(ros::NodeHandle nh, ros::NodeHandle pnh) {
    ros::NodeHandle nh_ = nh;
    ros::NodeHandle pnh_ = pnh;
    pose_init_ = false;
    odom_init_ = false;
    cur_speed = 0.0;
    pre_time = 0.0;
    model_pc_num_ = 0;
    history_trajectory.header.frame_id = "map";

    pthread_mutex_init(&mutex, NULL);
    pnh_.param<bool>("is_filter_ground", is_filter_ground, false);
    pnh_.param<double>("min_scan_range", param_min_scan_range, 1.0);
    pnh_.param<double>("max_scan_range", param_max_scan_range, 100.0);
    std::cout << "min_scan_range: " << param_min_scan_range << std::endl;
    std::cout << "max_scan_range: " << param_max_scan_range << std::endl;
    std::cout << std::endl;

    pnh_.param<double>("voxel_leaf_size", voxel_leaf_size, 2.0);

    pnh_.param<std::string>("map_frame", param_map_frame_, std::string("/map"));
    pnh_.param<std::string>("odom_frame", param_odom_frame_, std::string("/odom"));
    pnh_.param<std::string>("base_frame", param_base_frame_, std::string("base_link"));
    pnh_.param<std::string>("laser_frame", param_laser_frame_, std::string("laser_link"));
    pnh_.param<std::string>("map_topic", param_map_topic_, std::string("/map"));
    pnh_.param<std::string>("odom_topic", param_odom_topic_, std::string("/odomImu/odom_imu"));
    pnh_.param<std::string>("lidar_topic", param_lidar_topic_, std::string("/lslidar_point_cloud"));
    std::cout << "lidar topic is " << param_lidar_topic_ << std::endl;

    pnh_.param<double>("tf_timeout", param_tf_timeout_, 0.05);
    pnh_.param<bool>("use_odom", param_use_odom_, false);
    pnh_.param<double>("odom_timeout", param_odom_timeout_, 1);
    if (param_use_odom_) {
        ROS_WARN_STREAM("Use odom.");
    } else {
        ROS_WARN_STREAM("Unuse odom");
    }

    pnh_.param<double>("predict_error_thresh", param_predict_error_thresh_, 0.4);
    pnh_.param<double>("ndt_resolution", param_ndt_resolution_, 1.0);
    pnh_.param<int>("ndt_max_iterations", param_ndt_max_iterations_, 25);
    pnh_.param<double>("ndt_step_size", param_ndt_step_size_, 0.1);
    pnh_.param<double>("ndt_epsilon", param_ndt_epsilon_, 0.01);
    pnh_.param<int>("method_type", param_method_type_, 0);
    if (param_method_type_ == 0) {
        ROS_WARN_STREAM("Use ndt gpu");
    } else if (param_method_type_ == 3) {
        ROS_WARN_STREAM("Use ndt cpu");
    }

    pnh_.param<bool>("if_init_pose_with_param", param_init_pose_with_param, true);
    // pnh_.param<std::string>("global_map_file", map_file, "Confirm Location of Global Map.");
    std::string data_base;
    nh_.param<std::string>("data_base_folder", data_base, "");
    if (data_base == "") {
        ROS_ERROR("data_base folder undefined!");
        exit(1);
    }
    if (data_base.back() != '/') {
        data_base += '/';
    }
    map_file = data_base + "map/static_map/static.pcd";

    pnh_.param<bool>("debug", param_debug_, false);
    pub_ndt_state_ = nh_.advertise<automotive_msgs::NDTStat>("/NDTState", 100);
    pub_current_pose_ = nh_.advertise<geometry_msgs::PoseStamped>("/current_pose", 10);
    history_trajectory_pub = nh.advertise<nav_msgs::Path>("/ndt/history_trajectory", 1000);

    if (param_method_type_ == METHOD_CUDA)  // 定义GPU使用shared_ptr方式，因此需要初始化;
    {
#ifdef CUDA_FOUND
        ROS_INFO_STREAM("init gpu ndt.");
        anh_gpu_ndt_ptr = std::make_shared<gpu::GNormalDistributionsTransform>();
#else
        ROS_ERROR("param method_type set to cuda, but cuda_found not defined!");
#endif
    }

    // static tf (base_link -> laser_link)
    double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
    pnh_.param<double>("tf_x", _tf_x, 0.);
    pnh_.param<double>("tf_y", _tf_y, 0.);
    pnh_.param<double>("tf_z", _tf_z, 0.);
    pnh_.param<double>("tf_roll", _tf_roll, 0.);
    pnh_.param<double>("tf_pitch", _tf_pitch, 0.);
    pnh_.param<double>("tf_yaw", _tf_yaw, 0.);

    Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);
    Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());
    Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
    Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
    tf_btol_ = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();

    if (param_init_pose_with_param) {
        init_pose_with_param();
    }
    bool use_dynamic_points_map;
    pnh_.param<bool>("if_use_dynamic_points_map", use_dynamic_points_map, false);

    if (!load_map(map_file)) {
        if (!use_dynamic_points_map) {
            ROS_ERROR("[ndt_localization] load map failed! And use_dynamic_points_map=false, please confirm!");
            exit(1);
        } else {
            ROS_WARN("[ndt_localization] Cann't load map: %s, waitting for /points_map to update target-map", map_file);
        }
    }

    if (use_dynamic_points_map) {
        pthread_create(&thread, NULL, thread_func, NULL);  // 使用单独的线程进行地图的更新,避免影响本线程的时间
    }

    if (param_init_pose_with_param) {
        init_pose_with_param();
    }

    sub_initial_pose_ = nh_.subscribe<geometry_msgs::PoseWithCovarianceStamped>("/initialpose", 1, initialPoseCB);
    sub_point_cloud_ = nh_.subscribe<sensor_msgs::PointCloud2>(param_lidar_topic_, 2, pointCloudCB);

    if (param_use_odom_) {
        ROS_INFO_STREAM("[NDT localization] subscribe from OdomImu");
        sub_odomimu_ = nh_.subscribe<geometry_msgs::PoseStamped>(param_odom_topic_, 500, OdomImuCB);
    }

    sub_vehicle_status = nh_.subscribe<can_msgs::vehicle_status>("/vehicle_status", 100, feedbackCB);

    ROS_INFO("End init NDTLocalization");
    return true;

}  // init params
}  // namespace NDTLocalization